// src/main/launcher/loader/optifine.ts
import fs from 'fs/promises'
import fsSync from 'fs'
import path from 'path'
import { fileExists } from '../utils.js'
import { ensureVanillaVersion } from './vanilla.js'
import unzipper from 'unzipper'

const BMCLAPI_OPTIFINE_LIST = 'https://bmclapi2.bangbang93.com/optifine'
const BMCLAPI_OPTIFINE_DOWNLOAD = 'https://bmclapi2.bangbang93.com/optifine'

export async function getLatestOptiFineVersion(mcVersion: string): Promise<string> {
  try {
    const res = await fetch(`${BMCLAPI_OPTIFINE_LIST}/${mcVersion}`)
    if (!res.ok) throw new Error(`Không tải được danh sách OptiFine cho ${mcVersion}`)

    const versions: Array<{ type: string; patch: string }> = await res.json()
    if (versions.length === 0) throw new Error(`Không có OptiFine cho ${mcVersion}`)

    const stable = versions.filter(v => !v.type.includes('_J'))
    const selected = stable.length > 0
      ? stable.reduce((a, b) => (a.patch > b.patch ? a : b))
      : versions.reduce((a, b) => (a.patch > b.patch ? a : b))

    return `${selected.type}_${selected.patch}`
  } catch (err) {
    console.warn('[OptiFine] Lỗi lấy latest version:', err)
    throw err
  }
}

export async function installOptiFine(
  mcVersion: string,
  optiVersion: string | 'latest' = 'latest',
  gameDir: string,
  javaPath: string,
  signal: AbortSignal,
  log: (msg: string, level?: 'info' | 'warn' | 'error' | 'success') => void = console.log,
  downloadFile: (url: string, dest: string, name: string, signal: AbortSignal) => Promise<void>
): Promise<string> {
  let type: string
  let patch: string
  let displayVer: string
  let isPreview: boolean = false

  if (optiVersion === 'latest') {
    const versions: Array<{ type: string; patch: string }> = await fetch(`${BMCLAPI_OPTIFINE_LIST}/${mcVersion}`)
      .then(res => {
        if (!res.ok) throw new Error(`Không tải được danh sách OptiFine cho ${mcVersion}`)
        return res.json()
      })

    if (versions.length === 0) throw new Error(`Không có OptiFine cho ${mcVersion}`)

    const stable = versions.filter(v => !v.type.includes('_J'))
    const selected = stable.length > 0
      ? stable.reduce((a, b) => (a.patch > b.patch ? a : b))
      : versions.reduce((a, b) => (a.patch > b.patch ? a : b))

    type = selected.type
    patch = selected.patch
    displayVer = `${type}_${patch}`
    isPreview = type.includes('_J')
    log(`[OptiFine] Chọn phiên bản mới nhất: ${displayVer} ${isPreview ? '(preview)' : ''}`)
  } else {
    displayVer = optiVersion
    const lastUnderscore = optiVersion.lastIndexOf('_')
    if (lastUnderscore === -1) throw new Error('Định dạng phiên bản OptiFine chỉ định không hợp lệ (ví dụ: HD_U_J7_pre11)')

    type = optiVersion.substring(0, lastUnderscore)
    patch = optiVersion.substring(lastUnderscore + 1)
    isPreview = type.includes('_J')
    log(`[OptiFine] Dùng phiên bản chỉ định: ${displayVer} ${isPreview ? '(preview)' : ''}`)
  }

  const installerUrl = `${BMCLAPI_OPTIFINE_DOWNLOAD}/${mcVersion}/${type}/${patch}`
  const installerName = isPreview
    ? `preview_OptiFine_${mcVersion}_${type}_${patch}.jar`
    : `OptiFine_${mcVersion}_${type}_${patch}.jar`

  const installerDir = path.join(gameDir, 'installers', 'optifine')
  await fs.mkdir(installerDir, { recursive: true })
  const installerPath = path.join(installerDir, installerName)

  if (!(await fileExists(installerPath))) {
    log(`[OptiFine] Đang tải ${installerName} từ mirror BMCLAPI...`)
    await downloadFile(installerUrl, installerPath, installerName, signal)
    log('[OptiFine] Tải thành công')
  } else {
    log('[OptiFine] Sử dụng file đã tải trước đó')
  }

  const versionId = `${mcVersion}-OptiFine_${type}_${patch}`
  const optifineDir = path.join(gameDir, 'versions', versionId)
  const optifineJar = path.join(optifineDir, `${versionId}.jar`)
  const optifineJsonPath = path.join(optifineDir, `${versionId}.json`)

  if (await fileExists(optifineJsonPath) && await fileExists(optifineJar)) {
    log(`[OptiFine] Đã cài sẵn: ${versionId}`)
    return versionId
  }

  await ensureVanillaVersion(mcVersion, gameDir, signal, log, downloadFile)

  const vanillaDir = path.join(gameDir, 'versions', mcVersion)
  if (!await fileExists(path.join(vanillaDir, `${mcVersion}.jar`))) {
    throw new Error(`Không tìm thấy Minecraft JAR gốc cho ${mcVersion}`)
  }

  await fs.mkdir(optifineDir, { recursive: true })

  log('[OptiFine] Đang xử lý JAR OptiFine...')

  const directory = await unzipper.Open.file(installerPath)
  const modFileEntry = directory.files.find((f: any) => f.path.endsWith('_MOD.jar'))

  if (modFileEntry) {
    log('[OptiFine] Tìm thấy _MOD.jar → extract')
    await new Promise<void>((resolve, reject) => {
      modFileEntry.stream()
        .pipe(fsSync.createWriteStream(optifineJar))
        .on('finish', () => {
          log('[OptiFine] Extract _MOD.jar thành công')
          resolve()
        })
        .on('error', reject)
    })
  } else {
    log('[OptiFine] Đây là preview mới → copy file trực tiếp (đã patched sẵn)')
    await fs.copyFile(installerPath, optifineJar)
  }

  if (!(await fileExists(optifineJar))) {
    throw new Error('Xử lý thất bại: Không tạo được JAR OptiFine')
  }

  // === TẠO JSON CHỈ ĐỔI ID VÀ DOWNLOADS.URL (KHÔNG GHI ĐÈ MAINCLASS) ===
  const vanillaJsonPath = path.join(vanillaDir, `${mcVersion}.json`)
  const vanillaJson = JSON.parse(await fs.readFile(vanillaJsonPath, 'utf-8'))

  const optifineJson = {
    ...vanillaJson,
    id: versionId,
    downloads: {
      client: {
        sha1: vanillaJson.downloads.client.sha1,
        size: vanillaJson.downloads.client.size,
        url: ''
      }
    }
  }

  await fs.writeFile(optifineJsonPath, JSON.stringify(optifineJson, null, 2))
  log(`[OptiFine] Cài đặt thành công: ${versionId}`, 'success')

  return versionId
}